#include <iostream>
#include <vector>
#include <cmath>
#include <chrono>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <numeric>

using namespace std;

const double PI = acos(-1.0);

// Структура для коефіцієнта Фур'є (Ck = Ak + jBk)
struct FourierCoefficient {
    double Ak; // Реальна частина
    double Bk; // Уявна частина
};

// Структура для підрахунку операцій
struct OperationCount {
    long long additions = 0;
    long long multiplications = 0;
};

// 1.1 функція для обчислення одного к-того члена ряду Фур'є
pair<double, double> calculate_dft_term(double fi, int k, int i, int N) {
    double angle = (2.0 * PI * k * i) / N;
    double real_term = fi * cos(angle);
    double imag_term = -fi * sin(angle);
    return { real_term, imag_term };
}

// 1.2 Функція для Ck
FourierCoefficient calculate_fourier_coefficient(const vector<double>& signal, int k, int N, OperationCount& ops) {
    double sum_Ak = 0.0;
    double sum_Bk = 0.0;

    for (int i = 0; i < N; ++i) {
        pair<double, double> terms = calculate_dft_term(signal[i], k, i, N);
        sum_Ak += terms.first;
        sum_Bk += terms.second;
        ops.multiplications += 4;
        ops.additions += 2;
    }

    FourierCoefficient Ck;
    Ck.Ak = sum_Ak / N;
    Ck.Bk = sum_Bk / N;
    ops.multiplications += 2;

    return Ck;
}

// 1.3 графік функції спектру амплітуд та фаз
void plot_dft_spectra(const vector<double>& amplitude_spectrum, const vector<double>& phase_spectrum, int N) {
    ofstream data_file("dft_data.dat");
    data_file << "# k\tAmplitude\tPhase\n";
    for (int k = 0; k < N; ++k) {
        data_file << k << "\t" << amplitude_spectrum[k] << "\t" << phase_spectrum[k] << "\n";
    }
    data_file.close();

    ofstream plot_script("plot.gnu");
    plot_script << "set terminal wxt size 1000,600 title 'DFT Spectra'\n";
    plot_script << "set title 'DFT Amplitude and Phase Spectra'\n";
    plot_script << "set xlabel 'k (Harmonic number)'\n";
    plot_script << "set ylabel 'Amplitude |Ck|'\n";
    plot_script << "set y2label 'Phase phi_k (rad)'\n";
    plot_script << "set ytics nomirror\n";
    plot_script << "set y2tics\n";
    plot_script << "set grid\n";
    plot_script << "plot 'dft_data.dat' using 1:2 with linespoints pt 7 lc 'blue' title 'Amplitude' axes x1y1, \\\n";
    plot_script << "     'dft_data.dat' using 1:3 with linespoints pt 7 lc 'red' title 'Phase' axes x1y2\n";
    plot_script.close();

    cout << "\nCreated 'dft_data.dat' and 'plot.gnu' files." << endl;
    cout << "Executing gnuplot to generate the plot..." << endl;

    system("start \"DFT Spectra\" \"D:\\\\gnuplot\\\\bin\\\\gnuplot.exe\" -persist plot.gnu");
}

// Функція для запуску Частини 1
void run_part_one() {
    cout << "\n\n========== PART 1: DFT Analysis ==========\n" << endl;
    int student_n = 6;
    int N = 10 + student_n;
    vector<double> input_signal(N);

    cout << "--- Input Signal (N = " << N << ") ---" << endl;
    for (int i = 0; i < N; ++i) {
        input_signal[i] = 5.0 * sin(2.0 * PI * i / N) + 7.0 * cos(2.0 * PI * i / N);
        cout << "f[" << i << "] = " << fixed << setprecision(5) << input_signal[i] << endl;
    }
    cout << "------------------------------------------" << endl;

    vector<FourierCoefficient> all_coefficients;
    OperationCount total_ops;

    auto start_time = chrono::high_resolution_clock::now();
    for (int k = 0; k < N; ++k) {
        all_coefficients.push_back(calculate_fourier_coefficient(input_signal, k, N, total_ops));
    }
    auto end_time = chrono::high_resolution_clock::now();
    chrono::duration<double, milli> execution_time = end_time - start_time;

    vector<double> amplitude_spectrum(N);
    vector<double> phase_spectrum(N);

    cout << "\n--- DFT Results ---" << endl;
    cout << "==================================================================================\n";
    cout << left << setw(5) << "k"
        << setw(35) << "Coefficient Ck = Ak + jBk"
        << setw(25) << "Amplitude |Ck|"
        << setw(20) << "Phase phi_k (rad)" << endl;
    cout << "----------------------------------------------------------------------------------\n";

    for (int k = 0; k < N; ++k) {
        double Ak = all_coefficients[k].Ak;
        double Bk = all_coefficients[k].Bk;
        amplitude_spectrum[k] = sqrt(Ak * Ak + Bk * Bk);
        phase_spectrum[k] = atan2(Bk, Ak);

        cout << fixed << setprecision(5);
        cout << left << setw(5) << k;
        stringstream ss;
        ss << fixed << setprecision(5) << Ak << (Bk >= 0 ? " + j" : " - j") << abs(Bk);
        cout << left << setw(35) << ss.str();
        cout << left << setw(25) << amplitude_spectrum[k] << left << setw(20) << phase_spectrum[k] << endl;
    }
    cout << "==================================================================================\n";
    cout << "\n--- Performance Evaluation ---" << endl;
    cout << "a. Total computation time: " << execution_time.count() << " ms" << endl;
    cout << "b. Total operations:" << endl;
    cout << "   - Multiplications (approx.): " << total_ops.multiplications << endl;
    cout << "   - Additions (approx.):       " << total_ops.additions << endl;
    cout << "----------------------------------------------------------------------------------\n";
    plot_dft_spectra(amplitude_spectrum, phase_spectrum, N);
}

// 2.3 Функція для відбудови аналогового сигналу s(t)
double reconstruct_signal(double t, const vector<FourierCoefficient>& coeffs, double period) {
    double result = 0.0;
    for (size_t k = 0; k < coeffs.size(); ++k) {
        double angle = 2.0 * PI * k * t / period;
        result += coeffs[k].Ak * cos(angle) - coeffs[k].Bk * sin(angle);
    }
    return result;
}

// 2.3 Функція для побудови графіка відбудованого сигналу
void plot_reconstructed_signal(const vector<FourierCoefficient>& coeffs, const vector<double>& original_samples) {
    int M = original_samples.size();
    double period = M;

    ofstream data_file("reconstructed_data.dat");
    data_file << "# t\ts(t)\n";
    int plot_points = 200;
    for (int i = 0; i <= plot_points; ++i) {
        double t = (double)i / plot_points * period;
        data_file << t << "\t" << reconstruct_signal(t, coeffs, period) << "\n";
    }

    data_file << "\n\n# n\ts[n]\n";
    for (int i = 0; i < M; ++i) {
        data_file << i << "\t" << original_samples[i] << "\n";
    }
    data_file.close();

    ofstream plot_script("plot_reconstructed.gnu");
    plot_script << "set terminal wxt size 1000,600 title 'Signal Reconstruction'\n";
    plot_script << "set title 'Reconstructed Analog Signal s(t)'\n";
    plot_script << "set xlabel 'Time t'\n";
    plot_script << "set ylabel 's(t)'\n";
    plot_script << "set grid\n";
    plot_script << "set key top right\n";
    plot_script << "plot 'reconstructed_data.dat' index 0 using 1:2 with lines lc 'blue' title 'Reconstructed s(t)', \\\n";
    plot_script << "     'reconstructed_data.dat' index 1 using 1:2 with points pt 7 ps 2 lc 'red' title 'Original Samples s[n]'\n";
    plot_script.close();

    cout << "\nCreated 'reconstructed_data.dat' and 'plot_reconstructed.gnu' files." << endl;
    cout << "Executing gnuplot to generate the plot..." << endl;

    system("start \"Signal Reconstruction\" \"D:\\\\gnuplot\\\\bin\\\\gnuplot.exe\" -persist plot_reconstructed.gnu");
}

// Функція для запуску Частини 2
void run_part_two() {
    cout << "\n\n========== PART 2: Signal Reconstruction ==========\n" << endl;
    int student_n = 6;
    int N_val = 96 + student_n;
    int M = 8;

    cout << "N = 96 + " << student_n << " = " << N_val << endl;
    cout << "Binary representation of " << N_val << " is 1100110." << endl;
    cout << "Variant is even (6), so we add a 0 to the 8th bit." << endl;

    vector<double> s_signal = { 0, 1, 1, 0, 0, 1, 1, 0 };

    cout << "\n--- Generated 8-point signal s[n] ---" << endl;
    for (int i = 0; i < M; ++i) {
        cout << "s[" << i << "] = " << s_signal[i] << endl;
    }
    cout << "--------------------------------------" << endl;

    vector<FourierCoefficient> s_coefficients;
    OperationCount dummy_ops;

    // алгоритм для графіку
    for (int k = 0; k < M; ++k) {
        s_coefficients.push_back(calculate_fourier_coefficient(s_signal, k, M, dummy_ops));
    }

    // таблиця
    cout << "\n--- DFT Results for s[n] (Manual Values) ---" << endl;
    cout << "==================================================================================\n";
    cout << left << setw(5) << "k"
        << setw(35) << "Coefficient Ck"
        << setw(25) << "Amplitude |Ck|"
        << setw(20) << "Argument arg(Ck)" << endl;
    cout << "----------------------------------------------------------------------------------\n";

    // Значення були пораховані вручну у зошиті, розв'язування було одобрено викладачем
    cout << left << setw(5) << "0" << setw(35) << "0.5 + j0.0" << setw(25) << "sqrt(0.25)" << setw(20) << "0" << endl;
    cout << left << setw(5) << "1" << setw(35) << "0.0" << setw(25) << "0" << setw(20) << "0" << endl;
    cout << left << setw(5) << "2" << setw(35) << "-0.25 - j0.25" << setw(25) << "sqrt(0.125)" << setw(20) << "-3*pi/4" << endl;
    cout << left << setw(5) << "3" << setw(35) << "0.0" << setw(25) << "0" << setw(20) << "0" << endl;
    cout << left << setw(5) << "4" << setw(35) << "0.0" << setw(25) << "0" << setw(20) << "0" << endl;
    cout << left << setw(5) << "5" << setw(35) << "0.0" << setw(25) << "0" << setw(20) << "0" << endl;
    cout << left << setw(5) << "6" << setw(35) << "-0.25 + j0.25" << setw(25) << "sqrt(0.125)" << setw(20) << "3*pi/4" << endl;
    cout << left << setw(5) << "7" << setw(35) << "0.0" << setw(25) << "0" << setw(20) << "0" << endl;

    cout << "==================================================================================\n";

    // 2.3 Запис виразу та побудова графіка
    cout << "\n--- Reconstructed Analog Signal s(t) ---" << endl;

    // Загальний вигляд
    cout << "General Expression:" << endl;
    cout << "s(t) = |C0| + 2|C1|cos(2*pi*1*t/8 - argC1) + 2|C2|cos(2*pi*2*t/8 - argC2) + 2|C3|cos(2*pi*3*t/8 - argC2) + 2|C4|cos(2pi*4*t/8 - argC4)" << endl;

    // Фінальний вираз
    // s(t) = |C0| + 2|C2|cos(pi*t/2 + arg)
    cout << "\nFinal Expression with values:" << endl;
    cout << "s(t) = sqrt(0.25) + 2 * sqrt(0.125) * cos(pi*t/2 - 3*pi/4)" << endl;

    plot_reconstructed_signal(s_coefficients, s_signal);
}


int main() {
    run_part_one();
    run_part_two();
    return 0;
}
